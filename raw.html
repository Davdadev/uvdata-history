<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UV Data History - Raw Data</title>
    <style>
        body {
            font-family: monospace;
            margin: 20px;
            background: #f5f5f5;
        }
        
        .header {
            background: #333;
            color: white;
            padding: 15px;
            margin: -20px -20px 20px -20px;
        }
        
        .controls {
            margin-bottom: 20px;
            padding: 15px;
            background: white;
            border: 1px solid #ddd;
        }
        
        .button {
            padding: 8px 16px;
            margin-right: 10px;
            background: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            font-family: monospace;
        }
        
        .button:hover {
            background: #45a049;
        }
        
        .button-secondary {
            background: #666;
        }
        
        .button-secondary:hover {
            background: #555;
        }
        
        #output {
            background: white;
            padding: 20px;
            border: 1px solid #ddd;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 80vh;
            overflow: auto;
        }
        
        .status {
            padding: 10px;
            margin-bottom: 20px;
            background: #e7f3fe;
            border-left: 4px solid #2196F3;
        }
        
        .error {
            background: #ffebee;
            border-left: 4px solid #f44336;
        }
        
        select, input {
            padding: 8px;
            margin-right: 10px;
            font-family: monospace;
        }
        
        .filters {
            margin-top: 10px;
        }
        
        label {
            margin-right: 10px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>UV Data History - Raw Data Access</h1>
        <p>Machine-readable data output</p>
    </div>
    
    <div class="controls">
        <button class="button" onclick="loadAllData()">Load All Data</button>
        <button class="button" onclick="loadLatestData()">Load Latest Reading</button>
        <button class="button button-secondary" onclick="downloadJSON()">Download JSON</button>
        <button class="button button-secondary" onclick="downloadCSV()">Download CSV</button>
        <button class="button button-secondary" onclick="clearOutput()">Clear Output</button>
        
        <div class="filters">
            <label>Format:</label>
            <select id="formatSelect">
                <option value="json">JSON</option>
                <option value="json-pretty">JSON (Pretty)</option>
                <option value="table">HTML Table</option>
                <option value="csv">CSV</option>
            </select>
            
            <label>Location:</label>
            <select id="locationSelect">
                <option value="">All Locations</option>
            </select>
            
            <label>Hours Back:</label>
            <input type="number" id="hoursBack" value="48" min="1" max="168" style="width: 60px;">
        </div>
    </div>
    
    <div id="statusDiv"></div>
    <div id="output"></div>

    <script>
        // Configuration - must match index.html
        const DB_NAME = 'UVDataHistory';
        const DB_VERSION = 1;
        const STORE_NAME = 'uvReadings';
        
        // State
        let db = null;
        let currentData = [];
        
        // Initialize IndexedDB
        async function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                
                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    db = request.result;
                    resolve(db);
                };
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        const objectStore = db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
                        objectStore.createIndex('timestamp', 'timestamp', { unique: false });
                        objectStore.createIndex('location', 'location', { unique: false });
                        objectStore.createIndex('locationTime', ['location', 'timestamp'], { unique: false });
                    }
                };
            });
        }
        
        // Get UV data from IndexedDB
        async function getUVData(location = null, hoursBack = 48) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const index = location ? store.index('locationTime') : store.index('timestamp');
                
                const cutoffTime = Date.now() - (hoursBack * 60 * 60 * 1000);
                const range = location ? 
                    IDBKeyRange.bound([location, cutoffTime], [location, Date.now()]) :
                    IDBKeyRange.lowerBound(cutoffTime);
                
                const request = index.openCursor(range);
                const results = [];
                
                request.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        results.push(cursor.value);
                        cursor.continue();
                    } else {
                        resolve(results);
                    }
                };
                
                request.onerror = () => reject(request.error);
            });
        }
        
        // Get latest reading for each location
        async function getLatestReadings() {
            const allData = await getUVData();
            const locationMap = new Map();
            
            // Get latest reading per location
            allData.forEach(reading => {
                const existing = locationMap.get(reading.location);
                if (!existing || reading.timestamp > existing.timestamp) {
                    locationMap.set(reading.location, reading);
                }
            });
            
            return Array.from(locationMap.values());
        }
        
        // Load all data
        async function loadAllData() {
            try {
                showStatus('Loading data...', false);
                const location = document.getElementById('locationSelect').value;
                const hoursBack = parseInt(document.getElementById('hoursBack').value) || 48;
                
                currentData = await getUVData(location || null, hoursBack);
                displayData(currentData);
                
                showStatus(`Loaded ${currentData.length} records`, false);
            } catch (error) {
                console.error('Error loading data:', error);
                showStatus(`Error: ${error.message}`, true);
            }
        }
        
        // Load latest data
        async function loadLatestData() {
            try {
                showStatus('Loading latest data...', false);
                currentData = await getLatestReadings();
                displayData(currentData);
                showStatus(`Loaded latest readings for ${currentData.length} locations`, false);
            } catch (error) {
                console.error('Error loading data:', error);
                showStatus(`Error: ${error.message}`, true);
            }
        }
        
        // Display data based on selected format
        function displayData(data) {
            const format = document.getElementById('formatSelect').value;
            const output = document.getElementById('output');
            
            if (data.length === 0) {
                output.textContent = 'No data available. Please run the main application (index.html) to collect data first.';
                return;
            }
            
            switch (format) {
                case 'json':
                    output.textContent = JSON.stringify(data);
                    break;
                case 'json-pretty':
                    output.textContent = JSON.stringify(data, null, 2);
                    break;
                case 'table':
                    output.innerHTML = generateHTMLTable(data);
                    break;
                case 'csv':
                    output.textContent = generateCSV(data);
                    break;
            }
        }
        
        // Generate HTML table
        function generateHTMLTable(data) {
            if (data.length === 0) return '<p>No data</p>';
            
            let html = '<table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse; width: 100%;">';
            html += '<thead><tr>';
            html += '<th>ID</th>';
            html += '<th>Location</th>';
            html += '<th>UV Index</th>';
            html += '<th>Timestamp</th>';
            html += '<th>Date/Time</th>';
            html += '</tr></thead>';
            html += '<tbody>';
            
            data.forEach(record => {
                const date = new Date(record.timestamp);
                html += '<tr>';
                html += `<td>${record.id || 'N/A'}</td>`;
                html += `<td>${record.location}</td>`;
                html += `<td>${record.uvIndex.toFixed(2)}</td>`;
                html += `<td>${record.timestamp}</td>`;
                html += `<td>${date.toISOString()}</td>`;
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            return html;
        }
        
        // Generate CSV
        function generateCSV(data) {
            if (data.length === 0) return 'No data';
            
            let csv = 'id,location,uvIndex,timestamp,datetime\n';
            
            data.forEach(record => {
                const date = new Date(record.timestamp);
                csv += `${record.id || ''},`;
                csv += `"${record.location}",`;
                csv += `${record.uvIndex},`;
                csv += `${record.timestamp},`;
                csv += `"${date.toISOString()}"\n`;
            });
            
            return csv;
        }
        
        // Download JSON
        function downloadJSON() {
            if (currentData.length === 0) {
                alert('No data to download. Please load data first.');
                return;
            }
            
            const dataStr = JSON.stringify(currentData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `uv-data-raw-${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }
        
        // Download CSV
        function downloadCSV() {
            if (currentData.length === 0) {
                alert('No data to download. Please load data first.');
                return;
            }
            
            const csv = generateCSV(currentData);
            const dataBlob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `uv-data-raw-${new Date().toISOString().replace(/[:.]/g, '-')}.csv`;
            link.click();
            URL.revokeObjectURL(url);
        }
        
        // Clear output
        function clearOutput() {
            document.getElementById('output').textContent = '';
            currentData = [];
        }
        
        // Show status message
        function showStatus(message, isError) {
            const statusDiv = document.getElementById('statusDiv');
            statusDiv.className = 'status' + (isError ? ' error' : '');
            statusDiv.textContent = message;
            
            // Auto-hide after 5 seconds
            setTimeout(() => {
                statusDiv.textContent = '';
                statusDiv.className = '';
            }, 5000);
        }
        
        // Populate location dropdown
        async function populateLocations() {
            try {
                const allData = await getUVData();
                const locations = [...new Set(allData.map(d => d.location))].sort();
                
                const select = document.getElementById('locationSelect');
                locations.forEach(location => {
                    const option = document.createElement('option');
                    option.value = location;
                    option.textContent = location;
                    select.appendChild(option);
                });
            } catch (error) {
                console.error('Error populating locations:', error);
            }
        }
        
        // Update display when format changes
        document.getElementById('formatSelect').addEventListener('change', () => {
            if (currentData.length > 0) {
                displayData(currentData);
            }
        });
        
        // Initialize application
        async function init() {
            try {
                await initDB();
                await populateLocations();
                showStatus('Ready. Use buttons to load data.', false);
                
                // Auto-load latest data to show something useful
                await loadLatestData();
            } catch (error) {
                console.error('Initialization error:', error);
                showStatus(`Initialization failed: ${error.message}`, true);
            }
        }
        
        // Start the application when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
